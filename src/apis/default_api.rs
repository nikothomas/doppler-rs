/*
 * Core
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0-oas3.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`activity_logs_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivityLogsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_logs_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivityLogsRetrieveError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`audit_get_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuditGetUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_me`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthMeError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_oidc`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthOidcError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_revoke`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthRevokeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_request_policies_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeRequestPoliciesCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_request_policies_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeRequestPoliciesDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_request_policies_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeRequestPoliciesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_request_policies_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeRequestPoliciesListError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_request_policies_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeRequestPoliciesUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_logs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigLogsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_logs_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigLogsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_logs_rollback`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigLogsRollbackError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_add_trusted_ip`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsAddTrustedIpError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_clone`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsCloneError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_delete_trusted_ip`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsDeleteTrustedIpError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_inheritable`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsInheritableError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_inherits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsInheritsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_list_trusted_ips`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsListTrustedIpsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_lock`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsLockError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_unlock`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsUnlockError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`dynamic_secrets_issue_lease`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DynamicSecretsIssueLeaseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`dynamic_secrets_revoke_lease`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DynamicSecretsRevokeLeaseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`environments_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnvironmentsCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`environments_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnvironmentsDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`environments_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnvironmentsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`environments_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnvironmentsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`environments_rename`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnvironmentsRenameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOptionsError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`groups_add_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupsAddMemberError {
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`groups_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupsCreateError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`groups_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupsDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`groups_delete_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupsDeleteMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`groups_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupsGetError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`groups_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`groups_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupsUpdateError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`integrations_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IntegrationsCreateError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`integrations_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IntegrationsDeleteError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`integrations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IntegrationsGetError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`integrations_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IntegrationsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`integrations_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IntegrationsUpdateError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`invites_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InvitesListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_members_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectMembersAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_members_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectMembersDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_members_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectMembersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_members_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectMembersListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_members_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectMembersUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_roles_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectRolesCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_roles_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectRolesDeleteError {
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_roles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectRolesGetError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_roles_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectRolesListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_roles_list_permissions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectRolesListPermissionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_roles_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectRolesUpdateError {
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveMemberError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_download`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsDownloadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_names`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsNamesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_update_note`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsUpdateNoteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_account_tokens_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceAccountTokensCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_account_tokens_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceAccountTokensDeleteError {
    Status404(models::ServiceAccountTokensGet404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_account_tokens_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceAccountTokensGetError {
    Status404(models::ServiceAccountTokensGet404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_account_tokens_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceAccountTokensListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_accounts_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceAccountsCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_accounts_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceAccountsDeleteError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_accounts_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceAccountsGetError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_accounts_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceAccountsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_accounts_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceAccountsUpdateError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_tokens_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceTokensCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_tokens_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceTokensDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_tokens_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceTokensListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`syncs_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SyncsCreateError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`syncs_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SyncsDeleteError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`syncs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SyncsGetError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksAddError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksDeleteError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_disable`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksDisableError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_enable`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksEnableError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksGetError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksListError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksUpdateError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workplace_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkplaceGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workplace_roles_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkplaceRolesCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workplace_roles_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkplaceRolesDeleteError {
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workplace_roles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkplaceRolesGetError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workplace_roles_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkplaceRolesListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workplace_roles_list_permissions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkplaceRolesListPermissionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workplace_roles_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkplaceRolesUpdateError {
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workplace_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkplaceUpdateError {
    UnknownValue(serde_json::Value),
}


/// Activity Logs
pub async fn activity_logs_list(configuration: &configuration::Configuration, page: Option<&str>, per_page: Option<i32>) -> Result<models::ActivityLogsList200Response, Error<ActivityLogsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/v3/logs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ActivityLogsList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ActivityLogsList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivityLogsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Activity Log
pub async fn activity_logs_retrieve(configuration: &configuration::Configuration, log: &str) -> Result<models::ActivityLogsRetrieve200Response, Error<ActivityLogsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_log = log;

    let uri_str = format!("{}/v3/logs/log", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("log", &p_log.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ActivityLogsRetrieve200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ActivityLogsRetrieve200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivityLogsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a specific user in a workplace
pub async fn audit_get_user(configuration: &configuration::Configuration, workplace_user_id: &str, settings: Option<bool>) -> Result<models::AuditGetUser200Response, Error<AuditGetUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_workplace_user_id = workplace_user_id;
    let p_settings = settings;

    let uri_str = format!("{}/v3/workplace/users/{workplace_user_id}", configuration.base_path, workplace_user_id=crate::apis::urlencode(p_workplace_user_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_settings {
        req_builder = req_builder.query(&[("settings", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuditGetUser200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuditGetUser200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuditGetUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information about a token
pub async fn auth_me(configuration: &configuration::Configuration, ) -> Result<models::AuthMe200Response, Error<AuthMeError>> {

    let uri_str = format!("{}/v3/me", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthMe200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthMe200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthMeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Authenticate via a Service Account Identity with OIDC. Returns a short lived API token.
pub async fn auth_oidc(configuration: &configuration::Configuration, auth_oidc_request: Option<models::AuthOidcRequest>) -> Result<models::AuthOidc200Response, Error<AuthOidcError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_auth_oidc_request = auth_oidc_request;

    let uri_str = format!("{}/v3/auth/oidc", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_auth_oidc_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthOidc200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthOidc200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthOidcError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Revoke an auth token
pub async fn auth_revoke(configuration: &configuration::Configuration, auth_revoke_request: Option<models::AuthRevokeRequest>) -> Result<(), Error<AuthRevokeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_auth_revoke_request = auth_revoke_request;

    let uri_str = format!("{}/v3/auth/revoke", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_auth_revoke_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthRevokeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new change request policy
pub async fn change_request_policies_create(configuration: &configuration::Configuration, change_request_policies_update_request: Option<models::ChangeRequestPoliciesUpdateRequest>) -> Result<models::ChangeRequestPoliciesUpdate200Response, Error<ChangeRequestPoliciesCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_change_request_policies_update_request = change_request_policies_update_request;

    let uri_str = format!("{}/v3/workplace/change_request_policies", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_change_request_policies_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChangeRequestPoliciesUpdate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChangeRequestPoliciesUpdate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangeRequestPoliciesCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete an existing change request policy
pub async fn change_request_policies_delete(configuration: &configuration::Configuration, slug: &str) -> Result<models::ConfigsDelete200Response, Error<ChangeRequestPoliciesDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;

    let uri_str = format!("{}/v3/workplace/change_request_policies/change_request_policy/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigsDelete200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigsDelete200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangeRequestPoliciesDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch an existing change request policy
pub async fn change_request_policies_get(configuration: &configuration::Configuration, slug: &str) -> Result<models::ChangeRequestPoliciesGet200Response, Error<ChangeRequestPoliciesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;

    let uri_str = format!("{}/v3/workplace/change_request_policies/change_request_policy/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChangeRequestPoliciesGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChangeRequestPoliciesGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangeRequestPoliciesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List existing change request policies
pub async fn change_request_policies_list(configuration: &configuration::Configuration, ) -> Result<models::ChangeRequestPoliciesList200Response, Error<ChangeRequestPoliciesListError>> {

    let uri_str = format!("{}/v3/workplace/change_request_policies", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChangeRequestPoliciesList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChangeRequestPoliciesList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangeRequestPoliciesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update an existing change request policy
pub async fn change_request_policies_update(configuration: &configuration::Configuration, slug: &str, change_request_policies_update_request: Option<models::ChangeRequestPoliciesUpdateRequest>) -> Result<models::ChangeRequestPoliciesUpdate200Response, Error<ChangeRequestPoliciesUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_change_request_policies_update_request = change_request_policies_update_request;

    let uri_str = format!("{}/v3/workplace/change_request_policies/change_request_policy/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_change_request_policies_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChangeRequestPoliciesUpdate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChangeRequestPoliciesUpdate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangeRequestPoliciesUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Config Log
pub async fn config_logs_get(configuration: &configuration::Configuration, project: &str, config: &str, log: &str) -> Result<models::ConfigLogsGet200Response, Error<ConfigLogsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_log = log;

    let uri_str = format!("{}/v3/configs/config/logs/log", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    req_builder = req_builder.query(&[("log", &p_log.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigLogsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigLogsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigLogsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Config Logs
pub async fn config_logs_list(configuration: &configuration::Configuration, project: &str, config: &str, page: Option<i32>, per_page: Option<i32>) -> Result<models::ConfigLogsList200Response, Error<ConfigLogsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/v3/configs/config/logs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigLogsList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigLogsList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigLogsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Config Log
pub async fn config_logs_rollback(configuration: &configuration::Configuration, project: &str, config: &str, log: &str) -> Result<models::ConfigLogsRollback200Response, Error<ConfigLogsRollbackError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_log = log;

    let uri_str = format!("{}/v3/configs/config/logs/log/rollback", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    req_builder = req_builder.query(&[("log", &p_log.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigLogsRollback200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigLogsRollback200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigLogsRollbackError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn configs_add_trusted_ip(configuration: &configuration::Configuration, project: &str, config: &str, configs_add_trusted_ip_request: Option<models::ConfigsAddTrustedIpRequest>) -> Result<models::ConfigsAddTrustedIp200Response, Error<ConfigsAddTrustedIpError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_configs_add_trusted_ip_request = configs_add_trusted_ip_request;

    let uri_str = format!("{}/v3/configs/config/trusted_ips", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_configs_add_trusted_ip_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigsAddTrustedIp200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigsAddTrustedIp200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsAddTrustedIpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new branch config by cloning another. This duplicates a branch config and all its secrets.
pub async fn configs_clone(configuration: &configuration::Configuration, configs_clone_request: Option<models::ConfigsCloneRequest>) -> Result<models::ConfigsGet200Response, Error<ConfigsCloneError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_configs_clone_request = configs_clone_request;

    let uri_str = format!("{}/v3/configs/config/clone", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_configs_clone_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsCloneError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new branch config.
pub async fn configs_create(configuration: &configuration::Configuration, configs_create_request: Option<models::ConfigsCreateRequest>) -> Result<models::ConfigsGet200Response, Error<ConfigsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_configs_create_request = configs_create_request;

    let uri_str = format!("{}/v3/configs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_configs_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Permanently delete the config.
pub async fn configs_delete(configuration: &configuration::Configuration, project: &str, config: &str) -> Result<models::ConfigsDelete200Response, Error<ConfigsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;

    let uri_str = format!("{}/v3/configs/config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigsDelete200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigsDelete200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn configs_delete_trusted_ip(configuration: &configuration::Configuration, project: &str, config: &str, configs_add_trusted_ip_request: Option<models::ConfigsAddTrustedIpRequest>) -> Result<(), Error<ConfigsDeleteTrustedIpError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_configs_add_trusted_ip_request = configs_add_trusted_ip_request;

    let uri_str = format!("{}/v3/configs/config/trusted_ips", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_configs_add_trusted_ip_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsDeleteTrustedIpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch a config's details.
pub async fn configs_get(configuration: &configuration::Configuration, project: &str, config: &str) -> Result<models::ConfigsGet200Response, Error<ConfigsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;

    let uri_str = format!("{}/v3/configs/config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the inheritability of a config.
pub async fn configs_inheritable(configuration: &configuration::Configuration, configs_inheritable_request: Option<models::ConfigsInheritableRequest>) -> Result<models::ConfigsInheritable200Response, Error<ConfigsInheritableError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_configs_inheritable_request = configs_inheritable_request;

    let uri_str = format!("{}/v3/configs/config/inheritable", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_configs_inheritable_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigsInheritable200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigsInheritable200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsInheritableError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn configs_inherits(configuration: &configuration::Configuration, configs_inherits_request: Option<models::ConfigsInheritsRequest>) -> Result<models::ConfigsInherits200Response, Error<ConfigsInheritsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_configs_inherits_request = configs_inherits_request;

    let uri_str = format!("{}/v3/configs/config/inherits", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_configs_inherits_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigsInherits200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigsInherits200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsInheritsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch all configs.
pub async fn configs_list(configuration: &configuration::Configuration, project: &str, environment: Option<&str>, page: Option<i32>, per_page: Option<i32>) -> Result<models::ConfigsList200Response, Error<ConfigsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_environment = environment;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/v3/configs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    if let Some(ref param_value) = p_environment {
        req_builder = req_builder.query(&[("environment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigsList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigsList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn configs_list_trusted_ips(configuration: &configuration::Configuration, project: &str, config: &str) -> Result<models::ConfigsListTrustedIps200Response, Error<ConfigsListTrustedIpsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;

    let uri_str = format!("{}/v3/configs/config/trusted_ips", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigsListTrustedIps200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigsListTrustedIps200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsListTrustedIpsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Prevent the config from being renamed or deleted.
pub async fn configs_lock(configuration: &configuration::Configuration, configs_unlock_request: Option<models::ConfigsUnlockRequest>) -> Result<models::ConfigsLock200Response, Error<ConfigsLockError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_configs_unlock_request = configs_unlock_request;

    let uri_str = format!("{}/v3/configs/config/lock", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_configs_unlock_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigsLock200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigsLock200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsLockError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Allow the config to be renamed and/or deleted.
pub async fn configs_unlock(configuration: &configuration::Configuration, configs_unlock_request: Option<models::ConfigsUnlockRequest>) -> Result<models::ConfigsGet200Response, Error<ConfigsUnlockError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_configs_unlock_request = configs_unlock_request;

    let uri_str = format!("{}/v3/configs/config/unlock", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_configs_unlock_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsUnlockError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Modify an existing config.
pub async fn configs_update(configuration: &configuration::Configuration, configs_update_request: Option<models::ConfigsUpdateRequest>) -> Result<models::ConfigsUpdate200Response, Error<ConfigsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_configs_update_request = configs_update_request;

    let uri_str = format!("{}/v3/configs/config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_configs_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigsUpdate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigsUpdate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Issue a lease for a dynamic secret
pub async fn dynamic_secrets_issue_lease(configuration: &configuration::Configuration, dynamic_secrets_issue_lease_request: Option<models::DynamicSecretsIssueLeaseRequest>) -> Result<models::DynamicSecretsIssueLease200Response, Error<DynamicSecretsIssueLeaseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_dynamic_secrets_issue_lease_request = dynamic_secrets_issue_lease_request;

    let uri_str = format!("{}/v3/configs/config/dynamic_secrets/dynamic_secret/leases", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_dynamic_secrets_issue_lease_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DynamicSecretsIssueLease200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DynamicSecretsIssueLease200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DynamicSecretsIssueLeaseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn dynamic_secrets_revoke_lease(configuration: &configuration::Configuration, dynamic_secrets_revoke_lease_request: Option<models::DynamicSecretsRevokeLeaseRequest>) -> Result<models::ConfigsDelete200Response, Error<DynamicSecretsRevokeLeaseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_dynamic_secrets_revoke_lease_request = dynamic_secrets_revoke_lease_request;

    let uri_str = format!("{}/v3/configs/config/dynamic_secrets/dynamic_secret/leases/lease", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_dynamic_secrets_revoke_lease_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigsDelete200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigsDelete200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DynamicSecretsRevokeLeaseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Environment
pub async fn environments_create(configuration: &configuration::Configuration, project: &str, environments_create_request: Option<models::EnvironmentsCreateRequest>) -> Result<models::EnvironmentsCreate200Response, Error<EnvironmentsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_environments_create_request = environments_create_request;

    let uri_str = format!("{}/v3/environments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_environments_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EnvironmentsCreate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EnvironmentsCreate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnvironmentsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Environment
pub async fn environments_delete(configuration: &configuration::Configuration, project: &str, environment: &str) -> Result<(), Error<EnvironmentsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_environment = environment;

    let uri_str = format!("{}/v3/environments/environment", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("environment", &p_environment.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<EnvironmentsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Environment
pub async fn environments_get(configuration: &configuration::Configuration, project: &str, environment: &str) -> Result<models::EnvironmentsCreate200Response, Error<EnvironmentsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_environment = environment;

    let uri_str = format!("{}/v3/environments/environment", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("environment", &p_environment.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EnvironmentsCreate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EnvironmentsCreate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnvironmentsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Environments
pub async fn environments_list(configuration: &configuration::Configuration, project: &str) -> Result<models::EnvironmentsList200Response, Error<EnvironmentsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;

    let uri_str = format!("{}/v3/environments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EnvironmentsList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EnvironmentsList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnvironmentsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Environment
pub async fn environments_rename(configuration: &configuration::Configuration, project: &str, environment: &str, environments_rename_request: Option<models::EnvironmentsRenameRequest>) -> Result<models::EnvironmentsCreate200Response, Error<EnvironmentsRenameError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_environment = environment;
    let p_environments_rename_request = environments_rename_request;

    let uri_str = format!("{}/v3/environments/environment", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("environment", &p_environment.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_environments_rename_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EnvironmentsCreate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EnvironmentsCreate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnvironmentsRenameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn get_options(configuration: &configuration::Configuration, integration: &str) -> Result<serde_json::Value, Error<GetOptionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_integration = integration;

    let uri_str = format!("{}/v3/integrations/integration/options", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("integration", &p_integration.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOptionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn groups_add_member(configuration: &configuration::Configuration, slug: &str, groups_add_member_request: Option<models::GroupsAddMemberRequest>) -> Result<(), Error<GroupsAddMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_groups_add_member_request = groups_add_member_request;

    let uri_str = format!("{}/v3/workplace/groups/group/{slug}/members", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_groups_add_member_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GroupsAddMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn groups_create(configuration: &configuration::Configuration, groups_create_request: Option<models::GroupsCreateRequest>) -> Result<models::GroupsGet200Response, Error<GroupsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_groups_create_request = groups_create_request;

    let uri_str = format!("{}/v3/workplace/groups", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_groups_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GroupsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn groups_delete(configuration: &configuration::Configuration, slug: &str) -> Result<(), Error<GroupsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;

    let uri_str = format!("{}/v3/workplace/groups/group/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GroupsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn groups_delete_member(configuration: &configuration::Configuration, slug: &str, r#type: &str, member_slug: &str) -> Result<(), Error<GroupsDeleteMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_type = r#type;
    let p_member_slug = member_slug;

    let uri_str = format!("{}/v3/workplace/groups/group/{slug}/members/{type}/{member_slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug), type=crate::apis::urlencode(p_type), member_slug=crate::apis::urlencode(p_member_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GroupsDeleteMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn groups_get(configuration: &configuration::Configuration, slug: &str) -> Result<models::GroupsGet200Response, Error<GroupsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;

    let uri_str = format!("{}/v3/workplace/groups/group/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GroupsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn groups_list(configuration: &configuration::Configuration, page: Option<i32>, per_page: Option<i32>) -> Result<models::GroupsList200Response, Error<GroupsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/v3/workplace/groups", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupsList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupsList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GroupsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn groups_update(configuration: &configuration::Configuration, slug: &str, groups_update_request: Option<models::GroupsUpdateRequest>) -> Result<models::GroupsGet200Response, Error<GroupsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_groups_update_request = groups_update_request;

    let uri_str = format!("{}/v3/workplace/groups/group/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_groups_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GroupsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new external integration.
pub async fn integrations_create(configuration: &configuration::Configuration, integrations_create_request: Option<models::IntegrationsCreateRequest>) -> Result<models::IntegrationsGet200Response, Error<IntegrationsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_integrations_create_request = integrations_create_request;

    let uri_str = format!("{}/v3/integrations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_integrations_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IntegrationsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IntegrationsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IntegrationsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete an existing integration.
pub async fn integrations_delete(configuration: &configuration::Configuration, integration: &str) -> Result<serde_json::Value, Error<IntegrationsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_integration = integration;

    let uri_str = format!("{}/v3/integrations/integration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("integration", &p_integration.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IntegrationsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve an existing integration
pub async fn integrations_get(configuration: &configuration::Configuration, integration: &str) -> Result<models::IntegrationsGet200Response, Error<IntegrationsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_integration = integration;

    let uri_str = format!("{}/v3/integrations/integration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("integration", &p_integration.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IntegrationsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IntegrationsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IntegrationsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all existing integrations
pub async fn integrations_list(configuration: &configuration::Configuration, ) -> Result<models::IntegrationsList200Response, Error<IntegrationsListError>> {

    let uri_str = format!("{}/v3/integrations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IntegrationsList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IntegrationsList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IntegrationsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update an existing integration.
pub async fn integrations_update(configuration: &configuration::Configuration, integration: &str, integrations_update_request: Option<models::IntegrationsUpdateRequest>) -> Result<serde_json::Value, Error<IntegrationsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_integration = integration;
    let p_integrations_update_request = integrations_update_request;

    let uri_str = format!("{}/v3/integrations/integration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    req_builder = req_builder.query(&[("integration", &p_integration.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_integrations_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IntegrationsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn invites_list(configuration: &configuration::Configuration, page: Option<i32>, per_page: Option<i32>) -> Result<models::InvitesList200Response, Error<InvitesListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/v3/workplace/invites", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InvitesList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InvitesList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InvitesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_members_add(configuration: &configuration::Configuration, project: &str, project_members_add_request: Option<models::ProjectMembersAddRequest>) -> Result<models::ProjectMembersAdd200Response, Error<ProjectMembersAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_project_members_add_request = project_members_add_request;

    let uri_str = format!("{}/v3/projects/project/members", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_project_members_add_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectMembersAdd200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectMembersAdd200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectMembersAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_members_delete(configuration: &configuration::Configuration, r#type: &str, slug: &str, project: &str) -> Result<(), Error<ProjectMembersDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_slug = slug;
    let p_project = project;

    let uri_str = format!("{}/v3/projects/project/members/member/{type}/{slug}", configuration.base_path, type=crate::apis::urlencode(p_type), slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectMembersDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_members_get(configuration: &configuration::Configuration, project: &str, r#type: &str, slug: &str) -> Result<models::ProjectMembersAdd200Response, Error<ProjectMembersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_type = r#type;
    let p_slug = slug;

    let uri_str = format!("{}/v3/projects/project/members/member/{type}/{slug}", configuration.base_path, type=crate::apis::urlencode(p_type), slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectMembersAdd200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectMembersAdd200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectMembersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_members_list(configuration: &configuration::Configuration, project: &str, page: Option<i32>, per_page: Option<i32>) -> Result<models::ProjectMembersList200Response, Error<ProjectMembersListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/v3/projects/project/members", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectMembersList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectMembersList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectMembersListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_members_update(configuration: &configuration::Configuration, r#type: &str, slug: &str, project: &str, project_members_update_request: Option<models::ProjectMembersUpdateRequest>) -> Result<models::ProjectMembersAdd200Response, Error<ProjectMembersUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_slug = slug;
    let p_project = project;
    let p_project_members_update_request = project_members_update_request;

    let uri_str = format!("{}/v3/projects/project/members/member/{type}/{slug}", configuration.base_path, type=crate::apis::urlencode(p_type), slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_project_members_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectMembersAdd200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectMembersAdd200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectMembersUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_roles_create(configuration: &configuration::Configuration, project_roles_create_request: Option<models::ProjectRolesCreateRequest>) -> Result<models::ProjectRolesUpdate200Response, Error<ProjectRolesCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_roles_create_request = project_roles_create_request;

    let uri_str = format!("{}/v3/projects/roles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_project_roles_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectRolesUpdate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectRolesUpdate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectRolesCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_roles_delete(configuration: &configuration::Configuration, role: &str) -> Result<(), Error<ProjectRolesDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_role = role;

    let uri_str = format!("{}/v3/projects/roles/role/{role}", configuration.base_path, role=crate::apis::urlencode(p_role));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectRolesDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_roles_get(configuration: &configuration::Configuration, role: &str) -> Result<models::ProjectRolesGet200Response, Error<ProjectRolesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_role = role;

    let uri_str = format!("{}/v3/projects/roles/role/{role}", configuration.base_path, role=crate::apis::urlencode(p_role));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectRolesGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectRolesGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectRolesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_roles_list(configuration: &configuration::Configuration, ) -> Result<models::ProjectRolesList200Response, Error<ProjectRolesListError>> {

    let uri_str = format!("{}/v3/projects/roles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectRolesList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectRolesList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectRolesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_roles_list_permissions(configuration: &configuration::Configuration, ) -> Result<models::ProjectRolesListPermissions200Response, Error<ProjectRolesListPermissionsError>> {

    let uri_str = format!("{}/v3/projects/permissions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectRolesListPermissions200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectRolesListPermissions200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectRolesListPermissionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_roles_update(configuration: &configuration::Configuration, role: &str, project_roles_update_request: Option<models::ProjectRolesUpdateRequest>) -> Result<models::ProjectRolesUpdate200Response, Error<ProjectRolesUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_role = role;
    let p_project_roles_update_request = project_roles_update_request;

    let uri_str = format!("{}/v3/projects/roles/role/{role}", configuration.base_path, role=crate::apis::urlencode(p_role));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_project_roles_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectRolesUpdate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectRolesUpdate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectRolesUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Project
pub async fn projects_create(configuration: &configuration::Configuration, projects_create_request: Option<models::ProjectsCreateRequest>) -> Result<models::ProjectsCreate200Response, Error<ProjectsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_projects_create_request = projects_create_request;

    let uri_str = format!("{}/v3/projects", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_projects_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectsCreate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectsCreate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Project
pub async fn projects_delete(configuration: &configuration::Configuration, projects_delete_request: Option<models::ProjectsDeleteRequest>) -> Result<(), Error<ProjectsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_projects_delete_request = projects_delete_request;

    let uri_str = format!("{}/v3/projects/project", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_projects_delete_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Project
pub async fn projects_get(configuration: &configuration::Configuration, project: &str) -> Result<models::ProjectsCreate200Response, Error<ProjectsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;

    let uri_str = format!("{}/v3/projects/project", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectsCreate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectsCreate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Projects
pub async fn projects_list(configuration: &configuration::Configuration, page: Option<i32>, per_page: Option<i32>) -> Result<models::ProjectsList200Response, Error<ProjectsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/v3/projects", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectsList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectsList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Project
pub async fn projects_update(configuration: &configuration::Configuration, projects_update_request: Option<models::ProjectsUpdateRequest>) -> Result<models::ProjectsCreate200Response, Error<ProjectsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_projects_update_request = projects_update_request;

    let uri_str = format!("{}/v3/projects/project", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_projects_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectsCreate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectsCreate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn retrieve_member(configuration: &configuration::Configuration, group_slug: &str, member_type: &str, member_slug: &str) -> Result<models::GroupsGet200Response, Error<RetrieveMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_group_slug = group_slug;
    let p_member_type = member_type;
    let p_member_slug = member_slug;

    let uri_str = format!("{}/v3/workplace/groups/group/{group_slug}/members/{member_type}/{member_slug}", configuration.base_path, group_slug=crate::apis::urlencode(p_group_slug), member_type=crate::apis::urlencode(p_member_type), member_slug=crate::apis::urlencode(p_member_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Secret
pub async fn secrets_delete(configuration: &configuration::Configuration, project: &str, config: &str, name: &str) -> Result<(), Error<SecretsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_name = name;

    let uri_str = format!("{}/v3/configs/config/secret", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    req_builder = req_builder.query(&[("name", &p_name.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Download Secrets
pub async fn secrets_download(configuration: &configuration::Configuration, project: &str, config: &str, format: Option<&str>, name_transformer: Option<&str>, include_dynamic_secrets: Option<bool>, dynamic_secrets_ttl_sec: Option<i32>, secrets: Option<&str>) -> Result<models::SecretsDownload200Response, Error<SecretsDownloadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_format = format;
    let p_name_transformer = name_transformer;
    let p_include_dynamic_secrets = include_dynamic_secrets;
    let p_dynamic_secrets_ttl_sec = dynamic_secrets_ttl_sec;
    let p_secrets = secrets;

    let uri_str = format!("{}/v3/configs/config/secrets/download", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name_transformer {
        req_builder = req_builder.query(&[("name_transformer", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_dynamic_secrets {
        req_builder = req_builder.query(&[("include_dynamic_secrets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_dynamic_secrets_ttl_sec {
        req_builder = req_builder.query(&[("dynamic_secrets_ttl_sec", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_secrets {
        req_builder = req_builder.query(&[("secrets", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretsDownload200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretsDownload200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsDownloadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Secret
pub async fn secrets_get(configuration: &configuration::Configuration, project: &str, config: &str, name: &str) -> Result<models::SecretsGet200Response, Error<SecretsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_name = name;

    let uri_str = format!("{}/v3/configs/config/secret", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    req_builder = req_builder.query(&[("name", &p_name.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Secrets
pub async fn secrets_list(configuration: &configuration::Configuration, project: &str, config: &str, accepts: Option<&str>, include_dynamic_secrets: Option<bool>, dynamic_secrets_ttl_sec: Option<i32>, secrets: Option<&str>, include_managed_secrets: Option<bool>) -> Result<models::SecretsList200Response, Error<SecretsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_accepts = accepts;
    let p_include_dynamic_secrets = include_dynamic_secrets;
    let p_dynamic_secrets_ttl_sec = dynamic_secrets_ttl_sec;
    let p_secrets = secrets;
    let p_include_managed_secrets = include_managed_secrets;

    let uri_str = format!("{}/v3/configs/config/secrets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref param_value) = p_include_dynamic_secrets {
        req_builder = req_builder.query(&[("include_dynamic_secrets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_dynamic_secrets_ttl_sec {
        req_builder = req_builder.query(&[("dynamic_secrets_ttl_sec", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_secrets {
        req_builder = req_builder.query(&[("secrets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_managed_secrets {
        req_builder = req_builder.query(&[("include_managed_secrets", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accepts {
        req_builder = req_builder.header("accepts", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretsList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretsList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Secret Names
pub async fn secrets_names(configuration: &configuration::Configuration, project: &str, config: &str, include_dynamic_secrets: Option<bool>, include_managed_secrets: Option<bool>) -> Result<models::SecretsNames200Response, Error<SecretsNamesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_include_dynamic_secrets = include_dynamic_secrets;
    let p_include_managed_secrets = include_managed_secrets;

    let uri_str = format!("{}/v3/configs/config/secrets/names", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref param_value) = p_include_dynamic_secrets {
        req_builder = req_builder.query(&[("include_dynamic_secrets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_managed_secrets {
        req_builder = req_builder.query(&[("include_managed_secrets", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretsNames200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretsNames200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsNamesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Secrets
pub async fn secrets_update(configuration: &configuration::Configuration, secrets_update_request: Option<models::SecretsUpdateRequest>) -> Result<models::SecretsUpdate200Response, Error<SecretsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secrets_update_request = secrets_update_request;

    let uri_str = format!("{}/v3/configs/config/secrets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_secrets_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretsUpdate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretsUpdate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set a note on a secret
pub async fn secrets_update_note(configuration: &configuration::Configuration, project: Option<&str>, secrets_update_note_request: Option<models::SecretsUpdateNoteRequest>) -> Result<models::SecretsUpdateNote200Response, Error<SecretsUpdateNoteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_secrets_update_note_request = secrets_update_note_request;

    let uri_str = format!("{}/v3/projects/project/note", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_secrets_update_note_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretsUpdateNote200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretsUpdateNote200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsUpdateNoteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generate a new service account API token.
pub async fn service_account_tokens_create(configuration: &configuration::Configuration, service_account: &str, service_account_tokens_create_request: Option<models::ServiceAccountTokensCreateRequest>) -> Result<models::ServiceAccountTokensCreate200Response, Error<ServiceAccountTokensCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_account = service_account;
    let p_service_account_tokens_create_request = service_account_tokens_create_request;

    let uri_str = format!("{}/v3/workplace/service_accounts/service_account/{service_account}/tokens", configuration.base_path, service_account=crate::apis::urlencode(p_service_account));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_service_account_tokens_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceAccountTokensCreate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceAccountTokensCreate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceAccountTokensCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Revoke an existing service account API token.
pub async fn service_account_tokens_delete(configuration: &configuration::Configuration, service_account: &str, api_token: &str) -> Result<(), Error<ServiceAccountTokensDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_account = service_account;
    let p_api_token = api_token;

    let uri_str = format!("{}/v3/workplace/service_accounts/service_account/{service_account}/tokens/token/{api_token}", configuration.base_path, service_account=crate::apis::urlencode(p_service_account), api_token=crate::apis::urlencode(p_api_token));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceAccountTokensDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve information about a single service account API token.
pub async fn service_account_tokens_get(configuration: &configuration::Configuration, service_account: &str, api_token: &str) -> Result<models::ServiceAccountTokensGet200Response, Error<ServiceAccountTokensGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_account = service_account;
    let p_api_token = api_token;

    let uri_str = format!("{}/v3/workplace/service_accounts/service_account/{service_account}/tokens/token/{api_token}", configuration.base_path, service_account=crate::apis::urlencode(p_service_account), api_token=crate::apis::urlencode(p_api_token));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceAccountTokensGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceAccountTokensGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceAccountTokensGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List information about existing service account API tokens.
pub async fn service_account_tokens_list(configuration: &configuration::Configuration, service_account: &str, page: Option<i32>, per_page: Option<i32>) -> Result<models::ServiceAccountTokensList200Response, Error<ServiceAccountTokensListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_account = service_account;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/v3/workplace/service_accounts/service_account/{service_account}/tokens", configuration.base_path, service_account=crate::apis::urlencode(p_service_account));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceAccountTokensList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceAccountTokensList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceAccountTokensListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn service_accounts_create(configuration: &configuration::Configuration, service_accounts_update_request: Option<models::ServiceAccountsUpdateRequest>) -> Result<models::ServiceAccountsGet200Response, Error<ServiceAccountsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_accounts_update_request = service_accounts_update_request;

    let uri_str = format!("{}/v3/workplace/service_accounts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_service_accounts_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceAccountsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceAccountsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceAccountsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn service_accounts_delete(configuration: &configuration::Configuration, slug: &str) -> Result<(), Error<ServiceAccountsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;

    let uri_str = format!("{}/v3/workplace/service_accounts/service_account/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceAccountsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn service_accounts_get(configuration: &configuration::Configuration, slug: &str) -> Result<models::ServiceAccountsGet200Response, Error<ServiceAccountsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;

    let uri_str = format!("{}/v3/workplace/service_accounts/service_account/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceAccountsGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceAccountsGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceAccountsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn service_accounts_list(configuration: &configuration::Configuration, page: Option<i32>, per_page: Option<i32>) -> Result<models::ServiceAccountsList200Response, Error<ServiceAccountsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/v3/workplace/service_accounts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceAccountsList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceAccountsList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceAccountsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn service_accounts_update(configuration: &configuration::Configuration, slug: &str, service_accounts_update_request: Option<models::ServiceAccountsUpdateRequest>) -> Result<models::ServiceAccountsUpdate200Response, Error<ServiceAccountsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_service_accounts_update_request = service_accounts_update_request;

    let uri_str = format!("{}/v3/workplace/service_accounts/service_account/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_service_accounts_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceAccountsUpdate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceAccountsUpdate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceAccountsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Service Token
pub async fn service_tokens_create(configuration: &configuration::Configuration, service_tokens_create_request: Option<models::ServiceTokensCreateRequest>) -> Result<models::ServiceTokensCreate200Response, Error<ServiceTokensCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_tokens_create_request = service_tokens_create_request;

    let uri_str = format!("{}/v3/configs/config/tokens", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_service_tokens_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceTokensCreate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceTokensCreate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceTokensCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Service Token
pub async fn service_tokens_delete(configuration: &configuration::Configuration, service_tokens_delete_request: Option<models::ServiceTokensDeleteRequest>) -> Result<models::ConfigsDelete200Response, Error<ServiceTokensDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_tokens_delete_request = service_tokens_delete_request;

    let uri_str = format!("{}/v3/configs/config/tokens/token", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_service_tokens_delete_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigsDelete200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigsDelete200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceTokensDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Service Tokens
pub async fn service_tokens_list(configuration: &configuration::Configuration, project: &str, config: &str) -> Result<models::ServiceTokensList200Response, Error<ServiceTokensListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;

    let uri_str = format!("{}/v3/configs/config/tokens", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceTokensList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceTokensList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceTokensListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new secrets sync.
pub async fn syncs_create(configuration: &configuration::Configuration, project: &str, config: &str, syncs_create_request: Option<models::SyncsCreateRequest>) -> Result<models::SyncsCreate200Response, Error<SyncsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_syncs_create_request = syncs_create_request;

    let uri_str = format!("{}/v3/configs/config/syncs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_syncs_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SyncsCreate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SyncsCreate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SyncsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete an existing sync.
pub async fn syncs_delete(configuration: &configuration::Configuration, project: &str, config: &str, sync: &str, delete_from_target: bool) -> Result<serde_json::Value, Error<SyncsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_sync = sync;
    let p_delete_from_target = delete_from_target;

    let uri_str = format!("{}/v3/configs/config/syncs/sync", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    req_builder = req_builder.query(&[("sync", &p_sync.to_string())]);
    req_builder = req_builder.query(&[("delete_from_target", &p_delete_from_target.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SyncsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve an existing secrets sync.
pub async fn syncs_get(configuration: &configuration::Configuration, project: &str, config: &str, sync: &str) -> Result<models::SyncsCreate200Response, Error<SyncsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_sync = sync;

    let uri_str = format!("{}/v3/configs/config/syncs/sync", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    req_builder = req_builder.query(&[("sync", &p_sync.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SyncsCreate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SyncsCreate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SyncsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a specific user in a workplace
pub async fn users_get(configuration: &configuration::Configuration, slug: &str) -> Result<models::UsersGet200Response, Error<UsersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;

    let uri_str = format!("{}/v3/workplace/users/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UsersGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UsersGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all users within a workplace
pub async fn users_list(configuration: &configuration::Configuration, page: Option<i32>, email: Option<&str>) -> Result<models::UsersList200Response, Error<UsersListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page = page;
    let p_email = email;

    let uri_str = format!("{}/v3/workplace/users", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_email {
        req_builder = req_builder.query(&[("email", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UsersList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UsersList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a specific user for a workplace
pub async fn users_update(configuration: &configuration::Configuration, slug: &str, users_update_request: Option<models::UsersUpdateRequest>) -> Result<models::UsersGet200Response, Error<UsersUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_users_update_request = users_update_request;

    let uri_str = format!("{}/v3/workplace/users/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_users_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UsersGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UsersGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Webhook
pub async fn webhooks_add(configuration: &configuration::Configuration, project: Option<&str>, webhooks_add_request: Option<models::WebhooksAddRequest>) -> Result<serde_json::Value, Error<WebhooksAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_webhooks_add_request = webhooks_add_request;

    let uri_str = format!("{}/v3/webhooks", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_webhooks_add_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebhooksAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Webhook
pub async fn webhooks_delete(configuration: &configuration::Configuration, slug: &str, project: Option<&str>) -> Result<serde_json::Value, Error<WebhooksDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_project = project;

    let uri_str = format!("{}/v3/webhooks/webhook/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebhooksDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Webhook
pub async fn webhooks_disable(configuration: &configuration::Configuration, slug: &str, project: Option<&str>) -> Result<serde_json::Value, Error<WebhooksDisableError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_project = project;

    let uri_str = format!("{}/v3/webhooks/webhook/{slug}/disable", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebhooksDisableError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Webhook
pub async fn webhooks_enable(configuration: &configuration::Configuration, slug: &str, project: Option<&str>) -> Result<serde_json::Value, Error<WebhooksEnableError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_project = project;

    let uri_str = format!("{}/v3/webhooks/webhook/{slug}/enable", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebhooksEnableError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Webhook
pub async fn webhooks_get(configuration: &configuration::Configuration, slug: &str, project: Option<&str>) -> Result<serde_json::Value, Error<WebhooksGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_project = project;

    let uri_str = format!("{}/v3/webhooks/webhook/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebhooksGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Webhooks
pub async fn webhooks_list(configuration: &configuration::Configuration, project: Option<&str>) -> Result<serde_json::Value, Error<WebhooksListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;

    let uri_str = format!("{}/v3/webhooks", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebhooksListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Webhook
pub async fn webhooks_update(configuration: &configuration::Configuration, slug: &str, project: Option<&str>, webhooks_update_request: Option<models::WebhooksUpdateRequest>) -> Result<serde_json::Value, Error<WebhooksUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_project = project;
    let p_webhooks_update_request = webhooks_update_request;

    let uri_str = format!("{}/v3/webhooks/webhook/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_webhooks_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebhooksUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn workplace_get(configuration: &configuration::Configuration, ) -> Result<models::WorkplaceGet200Response, Error<WorkplaceGetError>> {

    let uri_str = format!("{}/v3/workplace", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkplaceGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkplaceGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkplaceGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn workplace_roles_create(configuration: &configuration::Configuration, workplace_roles_create_request: Option<models::WorkplaceRolesCreateRequest>) -> Result<models::WorkplaceRolesCreate200Response, Error<WorkplaceRolesCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_workplace_roles_create_request = workplace_roles_create_request;

    let uri_str = format!("{}/v3/workplace/roles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_workplace_roles_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkplaceRolesCreate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkplaceRolesCreate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkplaceRolesCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn workplace_roles_delete(configuration: &configuration::Configuration, role: &str) -> Result<(), Error<WorkplaceRolesDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_role = role;

    let uri_str = format!("{}/v3/workplace/roles/role/{role}", configuration.base_path, role=crate::apis::urlencode(p_role));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkplaceRolesDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn workplace_roles_get(configuration: &configuration::Configuration, role: &str) -> Result<models::WorkplaceRolesGet200Response, Error<WorkplaceRolesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_role = role;

    let uri_str = format!("{}/v3/workplace/roles/role/{role}", configuration.base_path, role=crate::apis::urlencode(p_role));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkplaceRolesGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkplaceRolesGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkplaceRolesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn workplace_roles_list(configuration: &configuration::Configuration, ) -> Result<models::WorkplaceRolesList200Response, Error<WorkplaceRolesListError>> {

    let uri_str = format!("{}/v3/workplace/roles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkplaceRolesList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkplaceRolesList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkplaceRolesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn workplace_roles_list_permissions(configuration: &configuration::Configuration, ) -> Result<models::WorkplaceRolesListPermissions200Response, Error<WorkplaceRolesListPermissionsError>> {

    let uri_str = format!("{}/v3/workplace/permissions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkplaceRolesListPermissions200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkplaceRolesListPermissions200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkplaceRolesListPermissionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn workplace_roles_update(configuration: &configuration::Configuration, role: &str, workplace_roles_update_request: Option<models::WorkplaceRolesUpdateRequest>) -> Result<models::WorkplaceRolesCreate200Response, Error<WorkplaceRolesUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_role = role;
    let p_workplace_roles_update_request = workplace_roles_update_request;

    let uri_str = format!("{}/v3/workplace/roles/role/{role}", configuration.base_path, role=crate::apis::urlencode(p_role));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_workplace_roles_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkplaceRolesCreate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkplaceRolesCreate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkplaceRolesUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn workplace_update(configuration: &configuration::Configuration, workplace_update_request: Option<models::WorkplaceUpdateRequest>) -> Result<models::WorkplaceGet200Response, Error<WorkplaceUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_workplace_update_request = workplace_update_request;

    let uri_str = format!("{}/v3/workplace", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_workplace_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkplaceGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkplaceGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkplaceUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

