/*
 * Core
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0-oas3.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`activity_logs_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivityLogsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`activity_logs_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivityLogsRetrieveError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`audit_get_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuditGetUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_me`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthMeError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_oidc`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthOidcError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_revoke`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthRevokeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_request_policies_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeRequestPoliciesCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_request_policies_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeRequestPoliciesDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_request_policies_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeRequestPoliciesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_request_policies_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeRequestPoliciesListError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_request_policies_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangeRequestPoliciesUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_logs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigLogsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_logs_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigLogsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_logs_rollback`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigLogsRollbackError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_add_trusted_ip`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsAddTrustedIpError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_clone`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsCloneError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_delete_trusted_ip`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsDeleteTrustedIpError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_inheritable`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsInheritableError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_inherits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsInheritsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_list_trusted_ips`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsListTrustedIpsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_lock`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsLockError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_unlock`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsUnlockError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configs_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigsUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`dynamic_secrets_issue_lease`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DynamicSecretsIssueLeaseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`dynamic_secrets_revoke_lease`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DynamicSecretsRevokeLeaseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`environments_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnvironmentsCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`environments_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnvironmentsDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`environments_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnvironmentsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`environments_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnvironmentsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`environments_rename`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnvironmentsRenameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOptionsError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`groups_add_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupsAddMemberError {
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`groups_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupsCreateError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`groups_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupsDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`groups_delete_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupsDeleteMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`groups_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupsGetError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`groups_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`groups_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupsUpdateError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`integrations_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IntegrationsCreateError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`integrations_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IntegrationsDeleteError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`integrations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IntegrationsGetError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`integrations_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IntegrationsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`integrations_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IntegrationsUpdateError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`invites_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InvitesListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_members_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectMembersAddError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_members_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectMembersDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_members_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectMembersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_members_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectMembersListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_members_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectMembersUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_roles_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectRolesCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_roles_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectRolesDeleteError {
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_roles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectRolesGetError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_roles_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectRolesListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_roles_list_permissions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectRolesListPermissionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_roles_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectRolesUpdateError {
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveMemberError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_download`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsDownloadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_names`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsNamesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`secrets_update_note`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecretsUpdateNoteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_account_tokens_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceAccountTokensCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_account_tokens_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceAccountTokensDeleteError {
    Status404(models::ServiceAccountTokenNotFoundResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_account_tokens_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceAccountTokensGetError {
    Status404(models::ServiceAccountTokenNotFoundResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_account_tokens_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceAccountTokensListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_accounts_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceAccountsCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_accounts_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceAccountsDeleteError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_accounts_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceAccountsGetError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_accounts_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceAccountsListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_accounts_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceAccountsUpdateError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_tokens_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceTokensCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_tokens_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceTokensDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`service_tokens_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServiceTokensListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`syncs_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SyncsCreateError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`syncs_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SyncsDeleteError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`syncs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SyncsGetError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksAddError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksDeleteError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_disable`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksDisableError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_enable`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksEnableError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksGetError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksListError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`webhooks_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhooksUpdateError {
    Status400(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workplace_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkplaceGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workplace_roles_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkplaceRolesCreateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workplace_roles_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkplaceRolesDeleteError {
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workplace_roles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkplaceRolesGetError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workplace_roles_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkplaceRolesListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workplace_roles_list_permissions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkplaceRolesListPermissionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workplace_roles_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkplaceRolesUpdateError {
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workplace_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkplaceUpdateError {
    UnknownValue(serde_json::Value),
}


/// Activity Logs
pub async fn activity_logs_list(configuration: &configuration::Configuration, page: Option<&str>, per_page: Option<i32>) -> Result<models::ActivityLogsListResponse, Error<ActivityLogsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/v3/logs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ActivityLogsListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ActivityLogsListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivityLogsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Activity Log
pub async fn activity_logs_retrieve(configuration: &configuration::Configuration, log: &str) -> Result<models::ActivityLogGetResponse, Error<ActivityLogsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_log = log;

    let uri_str = format!("{}/v3/logs/log", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("log", &p_log.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ActivityLogGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ActivityLogGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ActivityLogsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a specific user in a workplace
pub async fn audit_get_user(configuration: &configuration::Configuration, workplace_user_id: &str, settings: Option<bool>) -> Result<models::AuditUserGetResponse, Error<AuditGetUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_workplace_user_id = workplace_user_id;
    let p_settings = settings;

    let uri_str = format!("{}/v3/workplace/users/{workplace_user_id}", configuration.base_path, workplace_user_id=crate::apis::urlencode(p_workplace_user_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_settings {
        req_builder = req_builder.query(&[("settings", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuditUserGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuditUserGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuditGetUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information about a token
pub async fn auth_me(configuration: &configuration::Configuration, ) -> Result<models::AuthMeResponse, Error<AuthMeError>> {

    let uri_str = format!("{}/v3/me", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthMeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthMeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthMeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Authenticate via a Service Account Identity with OIDC. Returns a short lived API token.
pub async fn auth_oidc(configuration: &configuration::Configuration, oidc_auth_request: Option<models::OidcAuthRequest>) -> Result<models::OidcAuthResponse, Error<AuthOidcError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_oidc_auth_request = oidc_auth_request;

    let uri_str = format!("{}/v3/auth/oidc", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_oidc_auth_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OidcAuthResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OidcAuthResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthOidcError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Revoke an auth token
pub async fn auth_revoke(configuration: &configuration::Configuration, revoke_auth_request: Option<models::RevokeAuthRequest>) -> Result<(), Error<AuthRevokeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_revoke_auth_request = revoke_auth_request;

    let uri_str = format!("{}/v3/auth/revoke", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_revoke_auth_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthRevokeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new change request policy
pub async fn change_request_policies_create(configuration: &configuration::Configuration, update_change_request_policy_request: Option<models::UpdateChangeRequestPolicyRequest>) -> Result<models::ChangeRequestPolicyUpdateResponse, Error<ChangeRequestPoliciesCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_change_request_policy_request = update_change_request_policy_request;

    let uri_str = format!("{}/v3/workplace/change_request_policies", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_change_request_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChangeRequestPolicyUpdateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChangeRequestPolicyUpdateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangeRequestPoliciesCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete an existing change request policy
pub async fn change_request_policies_delete(configuration: &configuration::Configuration, slug: &str) -> Result<models::ConfigDeleteResponse, Error<ChangeRequestPoliciesDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;

    let uri_str = format!("{}/v3/workplace/change_request_policies/change_request_policy/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigDeleteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigDeleteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangeRequestPoliciesDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch an existing change request policy
pub async fn change_request_policies_get(configuration: &configuration::Configuration, slug: &str) -> Result<models::ChangeRequestPolicyGetResponse, Error<ChangeRequestPoliciesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;

    let uri_str = format!("{}/v3/workplace/change_request_policies/change_request_policy/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChangeRequestPolicyGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChangeRequestPolicyGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangeRequestPoliciesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List existing change request policies
pub async fn change_request_policies_list(configuration: &configuration::Configuration, ) -> Result<models::ChangeRequestPoliciesListResponse, Error<ChangeRequestPoliciesListError>> {

    let uri_str = format!("{}/v3/workplace/change_request_policies", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChangeRequestPoliciesListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChangeRequestPoliciesListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangeRequestPoliciesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update an existing change request policy
pub async fn change_request_policies_update(configuration: &configuration::Configuration, slug: &str, update_change_request_policy_request: Option<models::UpdateChangeRequestPolicyRequest>) -> Result<models::ChangeRequestPolicyUpdateResponse, Error<ChangeRequestPoliciesUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_update_change_request_policy_request = update_change_request_policy_request;

    let uri_str = format!("{}/v3/workplace/change_request_policies/change_request_policy/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_change_request_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChangeRequestPolicyUpdateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChangeRequestPolicyUpdateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ChangeRequestPoliciesUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Config Log
pub async fn config_logs_get(configuration: &configuration::Configuration, project: &str, config: &str, log: &str) -> Result<models::ConfigLogGetResponse, Error<ConfigLogsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_log = log;

    let uri_str = format!("{}/v3/configs/config/logs/log", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    req_builder = req_builder.query(&[("log", &p_log.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigLogGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigLogGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigLogsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Config Logs
pub async fn config_logs_list(configuration: &configuration::Configuration, project: &str, config: &str, page: Option<i32>, per_page: Option<i32>) -> Result<models::ConfigLogsListResponse, Error<ConfigLogsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/v3/configs/config/logs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigLogsListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigLogsListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigLogsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Config Log
pub async fn config_logs_rollback(configuration: &configuration::Configuration, project: &str, config: &str, log: &str) -> Result<models::ConfigLogRollbackResponse, Error<ConfigLogsRollbackError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_log = log;

    let uri_str = format!("{}/v3/configs/config/logs/log/rollback", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    req_builder = req_builder.query(&[("log", &p_log.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigLogRollbackResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigLogRollbackResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigLogsRollbackError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn configs_add_trusted_ip(configuration: &configuration::Configuration, project: &str, config: &str, add_trusted_ip_request: Option<models::AddTrustedIpRequest>) -> Result<models::TrustedIpAddResponse, Error<ConfigsAddTrustedIpError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_add_trusted_ip_request = add_trusted_ip_request;

    let uri_str = format!("{}/v3/configs/config/trusted_ips", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_add_trusted_ip_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TrustedIpAddResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TrustedIpAddResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsAddTrustedIpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new branch config by cloning another. This duplicates a branch config and all its secrets.
pub async fn configs_clone(configuration: &configuration::Configuration, clone_config_request: Option<models::CloneConfigRequest>) -> Result<models::ConfigGetResponse, Error<ConfigsCloneError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_clone_config_request = clone_config_request;

    let uri_str = format!("{}/v3/configs/config/clone", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_clone_config_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsCloneError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new branch config.
pub async fn configs_create(configuration: &configuration::Configuration, create_config_request: Option<models::CreateConfigRequest>) -> Result<models::ConfigGetResponse, Error<ConfigsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_create_config_request = create_config_request;

    let uri_str = format!("{}/v3/configs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_config_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Permanently delete the config.
pub async fn configs_delete(configuration: &configuration::Configuration, project: &str, config: &str) -> Result<models::ConfigDeleteResponse, Error<ConfigsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;

    let uri_str = format!("{}/v3/configs/config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigDeleteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigDeleteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn configs_delete_trusted_ip(configuration: &configuration::Configuration, project: &str, config: &str, add_trusted_ip_request: Option<models::AddTrustedIpRequest>) -> Result<(), Error<ConfigsDeleteTrustedIpError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_add_trusted_ip_request = add_trusted_ip_request;

    let uri_str = format!("{}/v3/configs/config/trusted_ips", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_add_trusted_ip_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsDeleteTrustedIpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch a config's details.
pub async fn configs_get(configuration: &configuration::Configuration, project: &str, config: &str) -> Result<models::ConfigGetResponse, Error<ConfigsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;

    let uri_str = format!("{}/v3/configs/config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the inheritability of a config.
pub async fn configs_inheritable(configuration: &configuration::Configuration, config_inheritable_request: Option<models::ConfigInheritableRequest>) -> Result<models::ConfigInheritableResponse, Error<ConfigsInheritableError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_config_inheritable_request = config_inheritable_request;

    let uri_str = format!("{}/v3/configs/config/inheritable", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_config_inheritable_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigInheritableResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigInheritableResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsInheritableError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn configs_inherits(configuration: &configuration::Configuration, config_inherits_request: Option<models::ConfigInheritsRequest>) -> Result<models::ConfigInheritsResponse, Error<ConfigsInheritsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_config_inherits_request = config_inherits_request;

    let uri_str = format!("{}/v3/configs/config/inherits", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_config_inherits_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigInheritsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigInheritsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsInheritsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch all configs.
pub async fn configs_list(configuration: &configuration::Configuration, project: &str, environment: Option<&str>, page: Option<i32>, per_page: Option<i32>) -> Result<models::ConfigsListResponse, Error<ConfigsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_environment = environment;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/v3/configs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    if let Some(ref param_value) = p_environment {
        req_builder = req_builder.query(&[("environment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigsListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigsListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn configs_list_trusted_ips(configuration: &configuration::Configuration, project: &str, config: &str) -> Result<models::TrustedIpsListResponse, Error<ConfigsListTrustedIpsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;

    let uri_str = format!("{}/v3/configs/config/trusted_ips", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TrustedIpsListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TrustedIpsListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsListTrustedIpsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Prevent the config from being renamed or deleted.
pub async fn configs_lock(configuration: &configuration::Configuration, unlock_config_request: Option<models::UnlockConfigRequest>) -> Result<models::ConfigLockResponse, Error<ConfigsLockError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_unlock_config_request = unlock_config_request;

    let uri_str = format!("{}/v3/configs/config/lock", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_unlock_config_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigLockResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigLockResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsLockError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Allow the config to be renamed and/or deleted.
pub async fn configs_unlock(configuration: &configuration::Configuration, unlock_config_request: Option<models::UnlockConfigRequest>) -> Result<models::ConfigGetResponse, Error<ConfigsUnlockError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_unlock_config_request = unlock_config_request;

    let uri_str = format!("{}/v3/configs/config/unlock", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_unlock_config_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsUnlockError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Modify an existing config.
pub async fn configs_update(configuration: &configuration::Configuration, update_config_request: Option<models::UpdateConfigRequest>) -> Result<models::ConfigUpdateResponse, Error<ConfigsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_config_request = update_config_request;

    let uri_str = format!("{}/v3/configs/config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_config_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigUpdateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigUpdateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Issue a lease for a dynamic secret
pub async fn dynamic_secrets_issue_lease(configuration: &configuration::Configuration, issue_dynamic_secret_lease_request: Option<models::IssueDynamicSecretLeaseRequest>) -> Result<models::DynamicSecretLeaseIssueResponse, Error<DynamicSecretsIssueLeaseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_issue_dynamic_secret_lease_request = issue_dynamic_secret_lease_request;

    let uri_str = format!("{}/v3/configs/config/dynamic_secrets/dynamic_secret/leases", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_issue_dynamic_secret_lease_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DynamicSecretLeaseIssueResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DynamicSecretLeaseIssueResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DynamicSecretsIssueLeaseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn dynamic_secrets_revoke_lease(configuration: &configuration::Configuration, revoke_dynamic_secret_lease_request: Option<models::RevokeDynamicSecretLeaseRequest>) -> Result<models::ConfigDeleteResponse, Error<DynamicSecretsRevokeLeaseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_revoke_dynamic_secret_lease_request = revoke_dynamic_secret_lease_request;

    let uri_str = format!("{}/v3/configs/config/dynamic_secrets/dynamic_secret/leases/lease", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_revoke_dynamic_secret_lease_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigDeleteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigDeleteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DynamicSecretsRevokeLeaseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Environment
pub async fn environments_create(configuration: &configuration::Configuration, project: &str, create_environment_request: Option<models::CreateEnvironmentRequest>) -> Result<models::EnvironmentCreateResponse, Error<EnvironmentsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_create_environment_request = create_environment_request;

    let uri_str = format!("{}/v3/environments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_environment_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EnvironmentCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EnvironmentCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnvironmentsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Environment
pub async fn environments_delete(configuration: &configuration::Configuration, project: &str, environment: &str) -> Result<(), Error<EnvironmentsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_environment = environment;

    let uri_str = format!("{}/v3/environments/environment", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("environment", &p_environment.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<EnvironmentsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Environment
pub async fn environments_get(configuration: &configuration::Configuration, project: &str, environment: &str) -> Result<models::EnvironmentCreateResponse, Error<EnvironmentsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_environment = environment;

    let uri_str = format!("{}/v3/environments/environment", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("environment", &p_environment.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EnvironmentCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EnvironmentCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnvironmentsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Environments
pub async fn environments_list(configuration: &configuration::Configuration, project: &str) -> Result<models::EnvironmentsListResponse, Error<EnvironmentsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;

    let uri_str = format!("{}/v3/environments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EnvironmentsListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EnvironmentsListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnvironmentsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Environment
pub async fn environments_rename(configuration: &configuration::Configuration, project: &str, environment: &str, rename_environment_request: Option<models::RenameEnvironmentRequest>) -> Result<models::EnvironmentCreateResponse, Error<EnvironmentsRenameError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_environment = environment;
    let p_rename_environment_request = rename_environment_request;

    let uri_str = format!("{}/v3/environments/environment", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("environment", &p_environment.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_rename_environment_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EnvironmentCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EnvironmentCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnvironmentsRenameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn get_options(configuration: &configuration::Configuration, integration: &str) -> Result<serde_json::Value, Error<GetOptionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_integration = integration;

    let uri_str = format!("{}/v3/integrations/integration/options", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("integration", &p_integration.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOptionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn groups_add_member(configuration: &configuration::Configuration, slug: &str, add_group_member_request: Option<models::AddGroupMemberRequest>) -> Result<(), Error<GroupsAddMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_add_group_member_request = add_group_member_request;

    let uri_str = format!("{}/v3/workplace/groups/group/{slug}/members", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_add_group_member_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GroupsAddMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn groups_create(configuration: &configuration::Configuration, create_group_request: Option<models::CreateGroupRequest>) -> Result<models::GroupGetResponse, Error<GroupsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_create_group_request = create_group_request;

    let uri_str = format!("{}/v3/workplace/groups", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_group_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GroupsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn groups_delete(configuration: &configuration::Configuration, slug: &str) -> Result<(), Error<GroupsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;

    let uri_str = format!("{}/v3/workplace/groups/group/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GroupsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn groups_delete_member(configuration: &configuration::Configuration, slug: &str, r#type: &str, member_slug: &str) -> Result<(), Error<GroupsDeleteMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_type = r#type;
    let p_member_slug = member_slug;

    let uri_str = format!("{}/v3/workplace/groups/group/{slug}/members/{type}/{member_slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug), type=crate::apis::urlencode(p_type), member_slug=crate::apis::urlencode(p_member_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GroupsDeleteMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn groups_get(configuration: &configuration::Configuration, slug: &str) -> Result<models::GroupGetResponse, Error<GroupsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;

    let uri_str = format!("{}/v3/workplace/groups/group/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GroupsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn groups_list(configuration: &configuration::Configuration, page: Option<i32>, per_page: Option<i32>) -> Result<models::GroupsListResponse, Error<GroupsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/v3/workplace/groups", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupsListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupsListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GroupsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn groups_update(configuration: &configuration::Configuration, slug: &str, update_group_request: Option<models::UpdateGroupRequest>) -> Result<models::GroupGetResponse, Error<GroupsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_update_group_request = update_group_request;

    let uri_str = format!("{}/v3/workplace/groups/group/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_group_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GroupsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new external integration.
pub async fn integrations_create(configuration: &configuration::Configuration, create_integration_request: Option<models::CreateIntegrationRequest>) -> Result<models::IntegrationGetResponse, Error<IntegrationsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_create_integration_request = create_integration_request;

    let uri_str = format!("{}/v3/integrations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_integration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IntegrationGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IntegrationGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IntegrationsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete an existing integration.
pub async fn integrations_delete(configuration: &configuration::Configuration, integration: &str) -> Result<serde_json::Value, Error<IntegrationsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_integration = integration;

    let uri_str = format!("{}/v3/integrations/integration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("integration", &p_integration.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IntegrationsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve an existing integration
pub async fn integrations_get(configuration: &configuration::Configuration, integration: &str) -> Result<models::IntegrationGetResponse, Error<IntegrationsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_integration = integration;

    let uri_str = format!("{}/v3/integrations/integration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("integration", &p_integration.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IntegrationGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IntegrationGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IntegrationsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all existing integrations
pub async fn integrations_list(configuration: &configuration::Configuration, ) -> Result<models::IntegrationsListResponse, Error<IntegrationsListError>> {

    let uri_str = format!("{}/v3/integrations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IntegrationsListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IntegrationsListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IntegrationsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update an existing integration.
pub async fn integrations_update(configuration: &configuration::Configuration, integration: &str, update_integration_request: Option<models::UpdateIntegrationRequest>) -> Result<serde_json::Value, Error<IntegrationsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_integration = integration;
    let p_update_integration_request = update_integration_request;

    let uri_str = format!("{}/v3/integrations/integration", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    req_builder = req_builder.query(&[("integration", &p_integration.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_integration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IntegrationsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn invites_list(configuration: &configuration::Configuration, page: Option<i32>, per_page: Option<i32>) -> Result<models::InvitesListResponse, Error<InvitesListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/v3/workplace/invites", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InvitesListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InvitesListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InvitesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_members_add(configuration: &configuration::Configuration, project: &str, add_project_member_request: Option<models::AddProjectMemberRequest>) -> Result<models::ProjectMemberAddResponse, Error<ProjectMembersAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_add_project_member_request = add_project_member_request;

    let uri_str = format!("{}/v3/projects/project/members", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_add_project_member_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectMemberAddResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectMemberAddResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectMembersAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_members_delete(configuration: &configuration::Configuration, r#type: &str, slug: &str, project: &str) -> Result<(), Error<ProjectMembersDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_slug = slug;
    let p_project = project;

    let uri_str = format!("{}/v3/projects/project/members/member/{type}/{slug}", configuration.base_path, type=crate::apis::urlencode(p_type), slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectMembersDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_members_get(configuration: &configuration::Configuration, project: &str, r#type: &str, slug: &str) -> Result<models::ProjectMemberAddResponse, Error<ProjectMembersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_type = r#type;
    let p_slug = slug;

    let uri_str = format!("{}/v3/projects/project/members/member/{type}/{slug}", configuration.base_path, type=crate::apis::urlencode(p_type), slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectMemberAddResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectMemberAddResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectMembersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_members_list(configuration: &configuration::Configuration, project: &str, page: Option<i32>, per_page: Option<i32>) -> Result<models::ProjectMembersListResponse, Error<ProjectMembersListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/v3/projects/project/members", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectMembersListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectMembersListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectMembersListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_members_update(configuration: &configuration::Configuration, r#type: &str, slug: &str, project: &str, update_project_member_request: Option<models::UpdateProjectMemberRequest>) -> Result<models::ProjectMemberAddResponse, Error<ProjectMembersUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_slug = slug;
    let p_project = project;
    let p_update_project_member_request = update_project_member_request;

    let uri_str = format!("{}/v3/projects/project/members/member/{type}/{slug}", configuration.base_path, type=crate::apis::urlencode(p_type), slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_project_member_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectMemberAddResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectMemberAddResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectMembersUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_roles_create(configuration: &configuration::Configuration, create_project_role_request: Option<models::CreateProjectRoleRequest>) -> Result<models::ProjectRoleUpdateResponse, Error<ProjectRolesCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_create_project_role_request = create_project_role_request;

    let uri_str = format!("{}/v3/projects/roles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_project_role_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectRoleUpdateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectRoleUpdateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectRolesCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_roles_delete(configuration: &configuration::Configuration, role: &str) -> Result<(), Error<ProjectRolesDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_role = role;

    let uri_str = format!("{}/v3/projects/roles/role/{role}", configuration.base_path, role=crate::apis::urlencode(p_role));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectRolesDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_roles_get(configuration: &configuration::Configuration, role: &str) -> Result<models::ProjectRoleGetResponse, Error<ProjectRolesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_role = role;

    let uri_str = format!("{}/v3/projects/roles/role/{role}", configuration.base_path, role=crate::apis::urlencode(p_role));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectRoleGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectRoleGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectRolesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_roles_list(configuration: &configuration::Configuration, ) -> Result<models::ProjectRolesListResponse, Error<ProjectRolesListError>> {

    let uri_str = format!("{}/v3/projects/roles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectRolesListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectRolesListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectRolesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_roles_list_permissions(configuration: &configuration::Configuration, ) -> Result<models::ProjectPermissionsResponse, Error<ProjectRolesListPermissionsError>> {

    let uri_str = format!("{}/v3/projects/permissions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectPermissionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectPermissionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectRolesListPermissionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn project_roles_update(configuration: &configuration::Configuration, role: &str, update_project_role_request: Option<models::UpdateProjectRoleRequest>) -> Result<models::ProjectRoleUpdateResponse, Error<ProjectRolesUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_role = role;
    let p_update_project_role_request = update_project_role_request;

    let uri_str = format!("{}/v3/projects/roles/role/{role}", configuration.base_path, role=crate::apis::urlencode(p_role));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_project_role_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectRoleUpdateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectRoleUpdateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectRolesUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Project
pub async fn projects_create(configuration: &configuration::Configuration, create_project_request: Option<models::CreateProjectRequest>) -> Result<models::ProjectCreateResponse, Error<ProjectsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_create_project_request = create_project_request;

    let uri_str = format!("{}/v3/projects", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_project_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Project
pub async fn projects_delete(configuration: &configuration::Configuration, delete_project_request: Option<models::DeleteProjectRequest>) -> Result<(), Error<ProjectsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_delete_project_request = delete_project_request;

    let uri_str = format!("{}/v3/projects/project", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_delete_project_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Project
pub async fn projects_get(configuration: &configuration::Configuration, project: &str) -> Result<models::ProjectCreateResponse, Error<ProjectsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;

    let uri_str = format!("{}/v3/projects/project", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Projects
pub async fn projects_list(configuration: &configuration::Configuration, page: Option<i32>, per_page: Option<i32>) -> Result<models::ProjectsListResponse, Error<ProjectsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/v3/projects", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectsListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectsListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Project
pub async fn projects_update(configuration: &configuration::Configuration, update_project_request: Option<models::UpdateProjectRequest>) -> Result<models::ProjectCreateResponse, Error<ProjectsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_project_request = update_project_request;

    let uri_str = format!("{}/v3/projects/project", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_project_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn retrieve_member(configuration: &configuration::Configuration, group_slug: &str, member_type: &str, member_slug: &str) -> Result<models::GroupGetResponse, Error<RetrieveMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_group_slug = group_slug;
    let p_member_type = member_type;
    let p_member_slug = member_slug;

    let uri_str = format!("{}/v3/workplace/groups/group/{group_slug}/members/{member_type}/{member_slug}", configuration.base_path, group_slug=crate::apis::urlencode(p_group_slug), member_type=crate::apis::urlencode(p_member_type), member_slug=crate::apis::urlencode(p_member_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Secret
pub async fn secrets_delete(configuration: &configuration::Configuration, project: &str, config: &str, name: &str) -> Result<(), Error<SecretsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_name = name;

    let uri_str = format!("{}/v3/configs/config/secret", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    req_builder = req_builder.query(&[("name", &p_name.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Download Secrets
pub async fn secrets_download(configuration: &configuration::Configuration, project: &str, config: &str, format: Option<&str>, name_transformer: Option<&str>, include_dynamic_secrets: Option<bool>, dynamic_secrets_ttl_sec: Option<i32>, secrets: Option<&str>) -> Result<models::SecretsDownloadResponse, Error<SecretsDownloadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_format = format;
    let p_name_transformer = name_transformer;
    let p_include_dynamic_secrets = include_dynamic_secrets;
    let p_dynamic_secrets_ttl_sec = dynamic_secrets_ttl_sec;
    let p_secrets = secrets;

    let uri_str = format!("{}/v3/configs/config/secrets/download", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name_transformer {
        req_builder = req_builder.query(&[("name_transformer", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_dynamic_secrets {
        req_builder = req_builder.query(&[("include_dynamic_secrets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_dynamic_secrets_ttl_sec {
        req_builder = req_builder.query(&[("dynamic_secrets_ttl_sec", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_secrets {
        req_builder = req_builder.query(&[("secrets", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretsDownloadResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretsDownloadResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsDownloadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Secret
pub async fn secrets_get(configuration: &configuration::Configuration, project: &str, config: &str, name: &str) -> Result<models::SecretGetResponse, Error<SecretsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_name = name;

    let uri_str = format!("{}/v3/configs/config/secret", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    req_builder = req_builder.query(&[("name", &p_name.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Secrets
pub async fn secrets_list(configuration: &configuration::Configuration, project: &str, config: &str, accepts: Option<&str>, include_dynamic_secrets: Option<bool>, dynamic_secrets_ttl_sec: Option<i32>, secrets: Option<&str>, include_managed_secrets: Option<bool>) -> Result<models::SecretsListResponse, Error<SecretsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_accepts = accepts;
    let p_include_dynamic_secrets = include_dynamic_secrets;
    let p_dynamic_secrets_ttl_sec = dynamic_secrets_ttl_sec;
    let p_secrets = secrets;
    let p_include_managed_secrets = include_managed_secrets;

    let uri_str = format!("{}/v3/configs/config/secrets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref param_value) = p_include_dynamic_secrets {
        req_builder = req_builder.query(&[("include_dynamic_secrets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_dynamic_secrets_ttl_sec {
        req_builder = req_builder.query(&[("dynamic_secrets_ttl_sec", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_secrets {
        req_builder = req_builder.query(&[("secrets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_managed_secrets {
        req_builder = req_builder.query(&[("include_managed_secrets", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accepts {
        req_builder = req_builder.header("accepts", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretsListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretsListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Secret Names
pub async fn secrets_names(configuration: &configuration::Configuration, project: &str, config: &str, include_dynamic_secrets: Option<bool>, include_managed_secrets: Option<bool>) -> Result<models::SecretNamesResponse, Error<SecretsNamesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_include_dynamic_secrets = include_dynamic_secrets;
    let p_include_managed_secrets = include_managed_secrets;

    let uri_str = format!("{}/v3/configs/config/secrets/names", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref param_value) = p_include_dynamic_secrets {
        req_builder = req_builder.query(&[("include_dynamic_secrets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_managed_secrets {
        req_builder = req_builder.query(&[("include_managed_secrets", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretNamesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretNamesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsNamesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Secrets
pub async fn secrets_update(configuration: &configuration::Configuration, update_secrets_request: Option<models::UpdateSecretsRequest>) -> Result<models::SecretsUpdateResponse, Error<SecretsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_secrets_request = update_secrets_request;

    let uri_str = format!("{}/v3/configs/config/secrets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_secrets_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretsUpdateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretsUpdateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set a note on a secret
pub async fn secrets_update_note(configuration: &configuration::Configuration, project: Option<&str>, update_secret_note_request: Option<models::UpdateSecretNoteRequest>) -> Result<models::SecretNoteResponse, Error<SecretsUpdateNoteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_update_secret_note_request = update_secret_note_request;

    let uri_str = format!("{}/v3/projects/project/note", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_secret_note_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecretNoteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecretNoteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SecretsUpdateNoteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generate a new service account API token.
pub async fn service_account_tokens_create(configuration: &configuration::Configuration, service_account: &str, create_service_account_token_request: Option<models::CreateServiceAccountTokenRequest>) -> Result<models::ServiceAccountTokenCreateResponse, Error<ServiceAccountTokensCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_account = service_account;
    let p_create_service_account_token_request = create_service_account_token_request;

    let uri_str = format!("{}/v3/workplace/service_accounts/service_account/{service_account}/tokens", configuration.base_path, service_account=crate::apis::urlencode(p_service_account));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_service_account_token_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceAccountTokenCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceAccountTokenCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceAccountTokensCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Revoke an existing service account API token.
pub async fn service_account_tokens_delete(configuration: &configuration::Configuration, service_account: &str, api_token: &str) -> Result<(), Error<ServiceAccountTokensDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_account = service_account;
    let p_api_token = api_token;

    let uri_str = format!("{}/v3/workplace/service_accounts/service_account/{service_account}/tokens/token/{api_token}", configuration.base_path, service_account=crate::apis::urlencode(p_service_account), api_token=crate::apis::urlencode(p_api_token));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceAccountTokensDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve information about a single service account API token.
pub async fn service_account_tokens_get(configuration: &configuration::Configuration, service_account: &str, api_token: &str) -> Result<models::ServiceAccountTokenGetResponse, Error<ServiceAccountTokensGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_account = service_account;
    let p_api_token = api_token;

    let uri_str = format!("{}/v3/workplace/service_accounts/service_account/{service_account}/tokens/token/{api_token}", configuration.base_path, service_account=crate::apis::urlencode(p_service_account), api_token=crate::apis::urlencode(p_api_token));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceAccountTokenGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceAccountTokenGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceAccountTokensGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List information about existing service account API tokens.
pub async fn service_account_tokens_list(configuration: &configuration::Configuration, service_account: &str, page: Option<i32>, per_page: Option<i32>) -> Result<models::ServiceAccountTokensListResponse, Error<ServiceAccountTokensListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_service_account = service_account;
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/v3/workplace/service_accounts/service_account/{service_account}/tokens", configuration.base_path, service_account=crate::apis::urlencode(p_service_account));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceAccountTokensListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceAccountTokensListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceAccountTokensListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn service_accounts_create(configuration: &configuration::Configuration, update_service_account_request: Option<models::UpdateServiceAccountRequest>) -> Result<models::ServiceAccountGetResponse, Error<ServiceAccountsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_service_account_request = update_service_account_request;

    let uri_str = format!("{}/v3/workplace/service_accounts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_service_account_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceAccountGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceAccountGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceAccountsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn service_accounts_delete(configuration: &configuration::Configuration, slug: &str) -> Result<(), Error<ServiceAccountsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;

    let uri_str = format!("{}/v3/workplace/service_accounts/service_account/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceAccountsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn service_accounts_get(configuration: &configuration::Configuration, slug: &str) -> Result<models::ServiceAccountGetResponse, Error<ServiceAccountsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;

    let uri_str = format!("{}/v3/workplace/service_accounts/service_account/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceAccountGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceAccountGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceAccountsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn service_accounts_list(configuration: &configuration::Configuration, page: Option<i32>, per_page: Option<i32>) -> Result<models::ServiceAccountsListResponse, Error<ServiceAccountsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page = page;
    let p_per_page = per_page;

    let uri_str = format!("{}/v3/workplace/service_accounts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceAccountsListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceAccountsListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceAccountsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn service_accounts_update(configuration: &configuration::Configuration, slug: &str, update_service_account_request: Option<models::UpdateServiceAccountRequest>) -> Result<models::ServiceAccountUpdateResponse, Error<ServiceAccountsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_update_service_account_request = update_service_account_request;

    let uri_str = format!("{}/v3/workplace/service_accounts/service_account/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_service_account_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceAccountUpdateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceAccountUpdateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceAccountsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Service Token
pub async fn service_tokens_create(configuration: &configuration::Configuration, create_service_token_request: Option<models::CreateServiceTokenRequest>) -> Result<models::ServiceTokenCreateResponse, Error<ServiceTokensCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_create_service_token_request = create_service_token_request;

    let uri_str = format!("{}/v3/configs/config/tokens", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_service_token_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceTokenCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceTokenCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceTokensCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Service Token
pub async fn service_tokens_delete(configuration: &configuration::Configuration, delete_service_token_request: Option<models::DeleteServiceTokenRequest>) -> Result<models::ConfigDeleteResponse, Error<ServiceTokensDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_delete_service_token_request = delete_service_token_request;

    let uri_str = format!("{}/v3/configs/config/tokens/token", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_delete_service_token_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigDeleteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigDeleteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceTokensDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Service Tokens
pub async fn service_tokens_list(configuration: &configuration::Configuration, project: &str, config: &str) -> Result<models::ServiceTokensListResponse, Error<ServiceTokensListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;

    let uri_str = format!("{}/v3/configs/config/tokens", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceTokensListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceTokensListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ServiceTokensListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new secrets sync.
pub async fn syncs_create(configuration: &configuration::Configuration, project: &str, config: &str, create_sync_request: Option<models::CreateSyncRequest>) -> Result<models::SyncCreateResponse, Error<SyncsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_create_sync_request = create_sync_request;

    let uri_str = format!("{}/v3/configs/config/syncs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_sync_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SyncCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SyncCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SyncsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete an existing sync.
pub async fn syncs_delete(configuration: &configuration::Configuration, project: &str, config: &str, sync: &str, delete_from_target: bool) -> Result<serde_json::Value, Error<SyncsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_sync = sync;
    let p_delete_from_target = delete_from_target;

    let uri_str = format!("{}/v3/configs/config/syncs/sync", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    req_builder = req_builder.query(&[("sync", &p_sync.to_string())]);
    req_builder = req_builder.query(&[("delete_from_target", &p_delete_from_target.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SyncsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve an existing secrets sync.
pub async fn syncs_get(configuration: &configuration::Configuration, project: &str, config: &str, sync: &str) -> Result<models::SyncCreateResponse, Error<SyncsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_config = config;
    let p_sync = sync;

    let uri_str = format!("{}/v3/configs/config/syncs/sync", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("project", &p_project.to_string())]);
    req_builder = req_builder.query(&[("config", &p_config.to_string())]);
    req_builder = req_builder.query(&[("sync", &p_sync.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SyncCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SyncCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SyncsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a specific user in a workplace
pub async fn users_get(configuration: &configuration::Configuration, slug: &str) -> Result<models::UserGetResponse, Error<UsersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;

    let uri_str = format!("{}/v3/workplace/users/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all users within a workplace
pub async fn users_list(configuration: &configuration::Configuration, page: Option<i32>, email: Option<&str>) -> Result<models::UsersListResponse, Error<UsersListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_page = page;
    let p_email = email;

    let uri_str = format!("{}/v3/workplace/users", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_email {
        req_builder = req_builder.query(&[("email", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UsersListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UsersListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a specific user for a workplace
pub async fn users_update(configuration: &configuration::Configuration, slug: &str, update_user_request: Option<models::UpdateUserRequest>) -> Result<models::UserGetResponse, Error<UsersUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_update_user_request = update_user_request;

    let uri_str = format!("{}/v3/workplace/users/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Webhook
pub async fn webhooks_add(configuration: &configuration::Configuration, project: Option<&str>, create_webhook_request: Option<models::CreateWebhookRequest>) -> Result<serde_json::Value, Error<WebhooksAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;
    let p_create_webhook_request = create_webhook_request;

    let uri_str = format!("{}/v3/webhooks", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_webhook_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebhooksAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Webhook
pub async fn webhooks_delete(configuration: &configuration::Configuration, slug: &str, project: Option<&str>) -> Result<serde_json::Value, Error<WebhooksDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_project = project;

    let uri_str = format!("{}/v3/webhooks/webhook/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebhooksDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Webhook
pub async fn webhooks_disable(configuration: &configuration::Configuration, slug: &str, project: Option<&str>) -> Result<serde_json::Value, Error<WebhooksDisableError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_project = project;

    let uri_str = format!("{}/v3/webhooks/webhook/{slug}/disable", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebhooksDisableError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Webhook
pub async fn webhooks_enable(configuration: &configuration::Configuration, slug: &str, project: Option<&str>) -> Result<serde_json::Value, Error<WebhooksEnableError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_project = project;

    let uri_str = format!("{}/v3/webhooks/webhook/{slug}/enable", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebhooksEnableError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Webhook
pub async fn webhooks_get(configuration: &configuration::Configuration, slug: &str, project: Option<&str>) -> Result<serde_json::Value, Error<WebhooksGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_project = project;

    let uri_str = format!("{}/v3/webhooks/webhook/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebhooksGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Webhooks
pub async fn webhooks_list(configuration: &configuration::Configuration, project: Option<&str>) -> Result<serde_json::Value, Error<WebhooksListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;

    let uri_str = format!("{}/v3/webhooks", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebhooksListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Webhook
pub async fn webhooks_update(configuration: &configuration::Configuration, slug: &str, project: Option<&str>, update_webhook_request: Option<models::UpdateWebhookRequest>) -> Result<serde_json::Value, Error<WebhooksUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_slug = slug;
    let p_project = project;
    let p_update_webhook_request = update_webhook_request;

    let uri_str = format!("{}/v3/webhooks/webhook/{slug}", configuration.base_path, slug=crate::apis::urlencode(p_slug));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_webhook_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebhooksUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn workplace_get(configuration: &configuration::Configuration, ) -> Result<models::WorkplaceGetResponse, Error<WorkplaceGetError>> {

    let uri_str = format!("{}/v3/workplace", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkplaceGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkplaceGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkplaceGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn workplace_roles_create(configuration: &configuration::Configuration, create_workplace_role_request: Option<models::CreateWorkplaceRoleRequest>) -> Result<models::WorkplaceRoleCreateResponse, Error<WorkplaceRolesCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_create_workplace_role_request = create_workplace_role_request;

    let uri_str = format!("{}/v3/workplace/roles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_workplace_role_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkplaceRoleCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkplaceRoleCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkplaceRolesCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn workplace_roles_delete(configuration: &configuration::Configuration, role: &str) -> Result<(), Error<WorkplaceRolesDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_role = role;

    let uri_str = format!("{}/v3/workplace/roles/role/{role}", configuration.base_path, role=crate::apis::urlencode(p_role));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkplaceRolesDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn workplace_roles_get(configuration: &configuration::Configuration, role: &str) -> Result<models::WorkplaceRoleGetResponse, Error<WorkplaceRolesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_role = role;

    let uri_str = format!("{}/v3/workplace/roles/role/{role}", configuration.base_path, role=crate::apis::urlencode(p_role));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkplaceRoleGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkplaceRoleGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkplaceRolesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn workplace_roles_list(configuration: &configuration::Configuration, ) -> Result<models::WorkplaceRolesListResponse, Error<WorkplaceRolesListError>> {

    let uri_str = format!("{}/v3/workplace/roles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkplaceRolesListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkplaceRolesListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkplaceRolesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn workplace_roles_list_permissions(configuration: &configuration::Configuration, ) -> Result<models::WorkplacePermissionsResponse, Error<WorkplaceRolesListPermissionsError>> {

    let uri_str = format!("{}/v3/workplace/permissions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkplacePermissionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkplacePermissionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkplaceRolesListPermissionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn workplace_roles_update(configuration: &configuration::Configuration, role: &str, update_workplace_role_request: Option<models::UpdateWorkplaceRoleRequest>) -> Result<models::WorkplaceRoleCreateResponse, Error<WorkplaceRolesUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_role = role;
    let p_update_workplace_role_request = update_workplace_role_request;

    let uri_str = format!("{}/v3/workplace/roles/role/{role}", configuration.base_path, role=crate::apis::urlencode(p_role));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_workplace_role_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkplaceRoleCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkplaceRoleCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkplaceRolesUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 
pub async fn workplace_update(configuration: &configuration::Configuration, update_workplace_request: Option<models::UpdateWorkplaceRequest>) -> Result<models::WorkplaceGetResponse, Error<WorkplaceUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_workplace_request = update_workplace_request;

    let uri_str = format!("{}/v3/workplace", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_workplace_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkplaceGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkplaceGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkplaceUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

